\unset ON_ERROR_STOP
\set VERBOSITY verbose

\echo
\echo 'CREATE TABLE IF NOT EXISTS available_tool ('
\echo '    tool_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,'
\echo '    tool_type TEXT NOT NULL,'
\echo '    available INTEGER DEFAULT 5 NOT NULL,'
\echo '    CHECK(available >= 0)'
\echo ');'
\prompt c

CREATE TABLE IF NOT EXISTS available_tool (
    tool_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tool_type TEXT NOT NULL,
    available INTEGER DEFAULT 5 NOT NULL,
    CHECK(available >= 0)
);

\echo
\echo 'CREATE TABLE IF NOT EXISTS checked_out_tool ('
\echo '    checked_out_by TEXT NOT NULL,'
\echo '    tool_id INTEGER NOT NULL REFERENCES available_tool'
\echo ');'
\prompt c

CREATE TABLE IF NOT EXISTS checked_out_tool (
    checked_out_by TEXT NOT NULL,
    tool_id INTEGER NOT NULL REFERENCES available_tool
);

\echo
\echo 'CREATE OR REPLACE FUNCTION check_checked_out_from_available()'
\echo 'RETURNS TRIGGER'
\echo 'LANGUAGE plpgsql'
\echo 'AS $$'
\echo 'DECLARE tool TEXT;'
\echo 'BEGIN'
\echo '    SELECT INTO tool a.tool_type'
\echo '    FROM available_tool a JOIN checked_out_tool d'
\echo '        ON ('
\echo '            a.tool_id = d.tool_id AND'
\echo '            d.tool_id = NEW.tool_id'
\echo '        )'
\echo '    GROUP BY a.available, a.tool_type'
\echo '    HAVING count(*) > a.available;'
\echo ''
\echo '    IF FOUND THEN'
\echo '        RAISE ''People have already checked out all the %s.'', tool'
\echo '            USING'
\echo '                ERRCODE = ''integrity_constraint_violation'','
\echo '                HINT = ''Consider getting more.'';'
\echo '    END IF;'
\echo '    RETURN NEW;'
\echo 'END;'
\echo '$$;'
\prompt c

CREATE OR REPLACE FUNCTION check_checked_out_from_available()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE tool TEXT;
BEGIN
    SELECT INTO tool a.tool_type
    FROM available_tool a JOIN checked_out_tool d
        ON (
            a.tool_id = d.tool_id AND
            d.tool_id = NEW.tool_id
        )
    GROUP BY a.available, a.tool_type
    HAVING count(*) > a.available;

    IF FOUND THEN
        RAISE 'People have already checked out all the %s.', tool
            USING
                ERRCODE = 'integrity_constraint_violation',
                HINT = 'Consider getting more.';
    END IF;
    RETURN NEW;
END;
$$;

\echo
\echo 'CREATE TRIGGER check_checked_out_from_available'
\echo '    AFTER INSERT OR UPDATE ON available_tool'
\echo '    FOR EACH ROW'
\echo '        EXECUTE PROCEDURE check_checked_out_from_available();'
\prompt c

CREATE TRIGGER check_checked_out_from_available
    AFTER INSERT OR UPDATE ON available_tool
    FOR EACH ROW
        EXECUTE PROCEDURE check_checked_out_from_available();

\echo
\echo 'CREATE OR REPLACE FUNCTION check_available_from_checked_out()'
\echo 'RETURNS TRIGGER'
\echo 'LANGUAGE plpgsql'
\echo 'AS $$'
\echo 'DECLARE'
\echo '    r RECORD;'
\echo 'BEGIN'
\echo '    SELECT tool_type, available INTO r'
\echo '    FROM available_tool a JOIN checked_out_tool d USING (tool_id)'
\echo '    WHERE NEW.tool_id = d.tool_id'
\echo '    GROUP BY d.tool_id, a.tool_type, a.available'
\echo '    HAVING count(*) > a.available;'
\echo ''
\echo '    IF FOUND THEN'
\echo '        RAISE ''There are already % checked-out %s.'', r.available, r.tool_type'
\echo '            USING'
\echo '                ERRCODE = ''integrity_constraint_violation'','
\echo '                HINT = ''Some of those tools need to come back first'';'
\echo '    END IF;'
\echo '    RETURN NEW;'
\echo 'END;'
\echo '$$;'
\prompt c

CREATE OR REPLACE FUNCTION check_available_from_checked_out()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    r RECORD;
BEGIN
    SELECT tool_type, available INTO r
    FROM available_tool a JOIN checked_out_tool d USING (tool_id)
    WHERE NEW.tool_id = d.tool_id
    GROUP BY d.tool_id, a.tool_type, a.available
    HAVING count(*) > a.available;

    IF FOUND THEN
        RAISE 'There are already % checked-out %s.', r.available, r.tool_type
            USING
                ERRCODE = 'integrity_constraint_violation',
                HINT = 'Some of those tools need to come back first';
    END IF;
    RETURN NEW;
END;
$$;

\echo
\echo 'CREATE TRIGGER check_available_from_checked_out'
\echo '    AFTER INSERT OR UPDATE ON checked_out_tool'
\echo '    FOR EACH ROW'
\echo '        EXECUTE PROCEDURE check_available_from_checked_out();'
\prompt c

CREATE TRIGGER check_available_from_checked_out
    AFTER INSERT OR UPDATE ON checked_out_tool
    FOR EACH ROW
        EXECUTE PROCEDURE check_available_from_checked_out();

\echo
\echo 'INSERT INTO available_tool (tool_type, available)'
\echo 'VALUES (''ball peen hammer'', 3);'
\prompt c

INSERT INTO available_tool (tool_type, available)
VALUES ('ball peen hammer', 3);

\echo
\echo 'INSERT INTO checked_out_tool(checked_out_by, tool_id)'
\echo 'VALUES'
\echo '    (''Leo'', 1),'
\echo '    (''Edith'', 1),'
\echo '    (''Ruth'', 1);'
\prompt c

INSERT INTO checked_out_tool(checked_out_by, tool_id)
VALUES
    ('Leo', 1),
    ('Edith', 1),
    ('Ruth', 1);

\echo
\echo 'INSERT INTO checked_out_tool(checked_out_by, tool_id)'
\echo 'VALUES'
\echo '    (''Benny'', 1);'
\prompt c

INSERT INTO checked_out_tool(checked_out_by, tool_id)
VALUES
    ('Benny', 1);

\echo
\echo 'UPDATE available_tool SET available = 2 WHERE tool_id = 1;'
\prompt c

UPDATE available_tool SET available = 2 WHERE tool_id = 1;

DROP TABLE IF EXISTS checked_out_tool;
DROP TABLE IF EXISTS available_tool;
DROP FUNCTION IF EXISTS check_available_from_checked_out();
DROP FUNCTION IF EXISTS check_checked_out_from_available();
